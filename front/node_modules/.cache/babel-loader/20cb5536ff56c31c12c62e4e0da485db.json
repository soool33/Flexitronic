{"ast":null,"code":"export default class PureCounter {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    /** Default configurations */\n    this.defaults = {\n      start: 0,\n      // Starting number [uint]\n      end: 100,\n      // End number [uint]\n      duration: 2000,\n      // Count duration [milisecond]\n      delay: 10,\n      // Count delay [milisecond]\n      once: true,\n      // Counting at once or recount when scroll [boolean]\n      pulse: false,\n      // Pulse count for certain time [boolean|milisecond]\n      decimals: 0,\n      // Decimal places [uint]\n      legacy: true,\n      // If this is true it will use the scroll event listener on browsers\n      filesizing: false,\n      // Is it for filesize?\n      currency: false,\n      // Is it for currency? Use it for set the symbol too [boolean|char|string]\n      separator: false,\n      // Do you want to use thausands separator? use it for set the symbol too [boolean|char|string]\n      formater: \"us-US\",\n      // Number toLocaleString locale/formater, by default is \"en-US\" [string|boolean:false]\n      selector: \".purecounter\" // HTML query selector for spesific element\n\n    };\n    /** Set default configuration based on user input */\n\n    this.configOptions = this.setOptions(options, this.defaults);\n    /** Get all elemenets based on default selector */\n\n    this.elements = document.querySelectorAll(this.configOptions.selector);\n    /** Get browser Intersection Listener Support */\n\n    this.intersectionSupport = this.intersectionListenerSupported();\n    /** Initiate event listened */\n\n    this.registerEventListeners();\n  }\n  /** This method is for create and merge configuration */\n\n\n  setOptions(config) {\n    let baseConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    // Create new Config object;\n    var newConfig = {}; // Loop config items to set it value into newConfig\n\n    for (var key in config) {\n      // if baseConfig is set, only accept the baseconfig property\n      if (Object.keys(baseConfig).length !== 0 && !baseConfig.hasOwnProperty(key)) continue; // var parse the config value\n\n      var val = this.parseValue(config[key]); // set the newConfig property value\n\n      newConfig[key] = val; // Exclusive for 'duration' or 'pulse' property, recheck the value\n      // If it's not a boolean, just set it to milisecond uint\n\n      if (key.match(/duration|pulse/)) {\n        newConfig[key] = typeof val != \"boolean\" ? val * 1000 : val;\n      }\n    } // Finally, we can just merge the baseConfig (if any), with newConfig.\n\n\n    return Object.assign({}, baseConfig, newConfig);\n  }\n  /** Initial setup method */\n\n\n  registerEventListeners() {\n    /** Get all elements with class 'purecounter' */\n    var elements = this.elements;\n    /** Return if no elements */\n\n    if (elements.length === 0) return;\n    /** Run animateElements base on Intersection Support */\n\n    if (this.intersectionSupport) {\n      var intersectObserver = new IntersectionObserver(this.animateElements.bind(this), {\n        root: null,\n        rootMargin: \"20px\",\n        threshold: 0.5\n      });\n      elements.forEach(element => {\n        intersectObserver.observe(element);\n      });\n    } else {\n      if (window.addEventListener) {\n        this.animateLegacy(elements);\n        window.addEventListener(\"scroll\", function (e) {\n          this.animateLegacy(elements);\n        }, {\n          passive: true\n        });\n      }\n    }\n  }\n  /** This legacy to make Purecounter use very lightweight & fast */\n\n\n  animateLegacy(elements) {\n    elements.forEach(element => {\n      var config = this.parseConfig(element);\n\n      if (config.legacy === true && this.elementIsInView(element)) {\n        this.animateElements([element]);\n      }\n    });\n  }\n  /** Main Element Count Animation */\n\n\n  animateElements(elements, observer) {\n    elements.forEach(element => {\n      var elm = element.target || element; // Just make sure which element will be used\n\n      var elementConfig = this.parseConfig(elm); // Get config value on that element\n      // console.log(elementConfig);\n      // If duration is less than or equal zero, just format the 'end' value\n\n      if (elementConfig.duration <= 0) {\n        return elm.innerHTML = this.formatNumber(elementConfig.end, elementConfig);\n      }\n\n      if (!observer && !this.elementIsInView(element) || observer && element.intersectionRatio < 0.5) {\n        var value = elementConfig.start > elementConfig.end ? elementConfig.end : elementConfig.start;\n        return elm.innerHTML = this.formatNumber(value, elementConfig);\n      } // If duration is more than 0, then start the counter\n\n\n      setTimeout(() => {\n        return this.startCounter(elm, elementConfig);\n      }, elementConfig.delay);\n    });\n  }\n  /** This is the the counter method */\n\n\n  startCounter(element, config) {\n    // First, get the increments step\n    var incrementsPerStep = (config.end - config.start) / (config.duration / config.delay); // Next, set the counter mode (Increment or Decrement)\n\n    var countMode = \"inc\"; // Set mode to 'decrement' and 'increment step' to minus if start is larger than end\n\n    if (config.start > config.end) {\n      countMode = \"dec\";\n      incrementsPerStep *= -1;\n    } // Next, determine the starting value\n\n\n    var currentCount = this.parseValue(config.start); // And then print it's value to the page\n\n    element.innerHTML = this.formatNumber(currentCount, config); // If the config 'once' is true, then set the 'duration' to 0\n\n    if (config.once === true) {\n      element.setAttribute(\"data-purecounter-duration\", 0);\n    } // Now, start counting with counterWorker using Interval method based on delay\n\n\n    var counterWorker = setInterval(() => {\n      // First, determine the next value base on current value, increment value, and count mode\n      var nextNum = this.nextNumber(currentCount, incrementsPerStep, countMode); // Next, print that value to the page\n\n      element.innerHTML = this.formatNumber(nextNum, config); // Now set that value to the current value, because it's already printed\n\n      currentCount = nextNum; // If the value is larger or less than the 'end' (base on mode), then  print the end value and stop the Interval\n\n      if (currentCount >= config.end && countMode === \"inc\" || currentCount <= config.end && countMode === \"dec\") {\n        element.innerHTML = this.formatNumber(config.end, config); // If 'pulse' is set ignore the 'once' config\n\n        if (config.pulse) {\n          // First set the 'duration' to zero\n          element.setAttribute(\"data-purecounter-duration\", 0); // Next, use timeout to reset it duration back based on 'pulse' config\n\n          setTimeout(() => {\n            element.setAttribute(\"data-purecounter-duration\", config.duration / 1000);\n          }, config.pulse);\n        } // Now, we can close the conterWorker peacefully\n\n\n        clearInterval(counterWorker);\n      }\n    }, config.delay);\n  }\n  /** This method is to generate the element Config */\n\n\n  parseConfig(element) {\n    // Next, get all 'data-precounter-*' attributes value. Store to array\n    var configValues = [].filter.call(element.attributes, function (attr) {\n      return /^data-purecounter-/.test(attr.name);\n    }); // Now, we create element config as an object\n\n    var elementConfig = configValues.length != 0 ? Object.assign({}, ...configValues.map(_ref => {\n      let {\n        name,\n        value\n      } = _ref;\n      var key = name.replace(\"data-purecounter-\", \"\").toLowerCase(),\n          val = this.parseValue(value);\n      return {\n        [key]: val\n      };\n    })) : {}; // Last setOptions and return\n\n    return this.setOptions(elementConfig, this.configOptions);\n  }\n  /** This method is to get the next number */\n\n\n  nextNumber(number, steps) {\n    let mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"inc\";\n    // First, get the exact value from the number and step (int or float)\n    number = this.parseValue(number);\n    steps = this.parseValue(steps); // Last, get the next number based on current number, increment step, and count mode\n    // Always return it as float\n\n    return parseFloat(mode === \"inc\" ? number + steps : number - steps);\n  }\n  /** This method is to get the converted number */\n\n\n  convertNumber(number, config) {\n    /** Use converter if filesizing or currency is on */\n    if (config.filesizing || config.currency) {\n      number = Math.abs(Number(number)); // Get the absolute value of number\n\n      var baseNumber = 1000,\n          // Base multiplying treshold\n      symbol = config.currency && typeof config.currency === \"string\" ? config.currency : \"\",\n          // Set the Currency Symbol (if any)\n      limit = config.decimals || 1,\n          // Set the decimal limit (default is 1)\n      uint = [\"\", \"K\", \"M\", \"B\", \"T\"],\n          // Number uint based exponent threshold\n      value = \"\"; // Define value variable\n\n      /** Changes base number and its uint for filesizing */\n\n      if (config.filesizing) {\n        baseNumber = 1024; // Use 1024 instead of 1000\n\n        uint = [\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"]; // Change to 'bytes' uint\n      }\n      /** Set value based on the threshold */\n\n\n      for (var i = 4; i >= 0; i--) {\n        // If the exponent is 0\n        if (i === 0) value = `${number.toFixed(limit)} ${uint[i]}`; // If the exponent is above zero\n\n        if (number >= this.getFilesizeThreshold(baseNumber, i)) {\n          value = `${(number / this.getFilesizeThreshold(baseNumber, i)).toFixed(limit)} ${uint[i]}`;\n          break;\n        }\n      } // Apply symbol before the value and return it as string\n\n\n      return symbol + value;\n    } else {\n      /** Return its value as float if not using filesizing or currency*/\n      return parseFloat(number);\n    }\n  }\n  /** This method will get the given base.  */\n\n\n  getFilesizeThreshold(baseNumber, index) {\n    return Math.pow(baseNumber, index);\n  }\n  /** This method is to get the last formated number */\n\n\n  applySeparator(value, config) {\n    // Get replaced value based on it's separator/symbol.\n    function replacedValue(val, separator) {\n      // Well this is my regExp for detecting the Thausands Separator\n      // I use 3 groups to determine it's separator\n      // THen the group 4 is to get the decimals value\n      var separatorRegExp = /^(?:(\\d{1,3},(?:\\d{1,3},?)*)|(\\d{1,3}\\.(?:\\d{1,3}\\.?)*)|(\\d{1,3}(?:\\s\\d{1,3})*))([\\.,]?\\d{0,2}?)$/gi;\n      return val.replace(separatorRegExp, function (match, g1, g2, g3, g4) {\n        // set initial result value\n        var result = \"\",\n            sep = \"\";\n\n        if (g1 !== undefined) {\n          // Group 1 is using comma as thausands separator, and period as decimal separator\n          result = g1.replace(new RegExp(/,/gi, \"gi\"), separator);\n          sep = \",\";\n        } else if (g2 !== undefined) {\n          // Group 2 is using period as thausands separator, and comma as decimal separator\n          result = g2.replace(new RegExp(/\\./gi, \"gi\"), separator);\n        } else if (g3 !== undefined) {\n          // Group 3 is using space as thausands separator, and comma as decimal separator\n          result = g3.replace(new RegExp(/ /gi, \"gi\"), separator);\n        }\n\n        if (g4 !== undefined) {\n          var decimal = sep !== \",\" ? separator !== \",\" ? \",\" : \".\" : \".\";\n          result += g4.replace(new RegExp(/\\.|,/gi, \"gi\"), decimal);\n        } // Returning result value;\n\n\n        return result;\n      });\n    } // If config formater is not false, then apply separator\n\n\n    if (config.formater) {\n      // Now get the separator symbol\n      var symbol = config.separator // if config separator is setted\n      ? typeof config.separator === \"string\" // Check the type of value\n      ? config.separator // If it's type is string, then apply it's value\n      : \",\" // If it's not string (boolean), then apply comma as default separator\n      : \"\"; // Special exception when locale is not 'en-US' but separator value is 'true'\n      // Use it's default locale thausands separator.\n\n      if (config.formater !== \"en-US\" && config.separator === true) {\n        return value;\n      } // Return the replaced Value based on it's symbol\n\n\n      return replacedValue(value, symbol);\n    } // If config formater is false, then return it's default value\n\n\n    return value;\n  }\n  /** This method is to get formated number to be printed in the page */\n\n\n  formatNumber(number, config) {\n    // This is the configuration for 'toLocaleString' method\n    var strConfig = {\n      minimumFractionDigits: config.decimals,\n      maximumFractionDigits: config.decimals\n    }; // Get locale from config formater\n\n    var locale = typeof config.formater === \"string\" ? config.formater : undefined; // Set and convert the number base on its config.\n\n    number = this.convertNumber(number, config); // Now format the number to string base on it's locale\n\n    number = config.formater ? number.toLocaleString(locale, strConfig) : parseInt(number).toString(); // Last, apply the number separator using number as string\n\n    return this.applySeparator(number, config);\n  }\n\n  getLocaleSeparator() {\n    var regExp = /^(?:(\\d{1,3}(?:,\\d{1,3})*(?:\\.\\d{0,3})?)|(\\d{1,3}(?:\\.\\d{1,3})*(?:,\\d{0,3})?)|(\\d{1,3}(?:\\s\\d{1,3})*(?:,\\d{0,3})?))$/i;\n    return;\n  }\n  /** This method is to get the parsed value */\n\n\n  parseValue(data) {\n    // If number with dot (.), will be parsed as float\n    if (/^[0-9]+\\.[0-9]+$/.test(data)) {\n      return parseFloat(data);\n    } // If just number, will be parsed as integer\n\n\n    if (/^[0-9]+$/.test(data)) {\n      return parseInt(data);\n    } // If it's boolean string, will be parsed as boolean\n\n\n    if (/^true|false/i.test(data)) {\n      return /^true/i.test(data);\n    } // Return it's value as default\n\n\n    return data;\n  }\n  /** This method is to detect the element is in view or not. */\n\n\n  elementIsInView(element) {\n    var top = element.offsetTop;\n    var left = element.offsetLeft;\n    var width = element.offsetWidth;\n    var height = element.offsetHeight;\n\n    while (element.offsetParent) {\n      element = element.offsetParent;\n      top += element.offsetTop;\n      left += element.offsetLeft;\n    }\n\n    return top >= window.pageYOffset && left >= window.pageXOffset && top + height <= window.pageYOffset + window.innerHeight && left + width <= window.pageXOffset + window.innerWidth;\n  }\n  /** Just some condition to check browser Intersection Support */\n\n\n  intersectionListenerSupported() {\n    return \"IntersectionObserver\" in window && \"IntersectionObserverEntry\" in window && \"intersectionRatio\" in window.IntersectionObserverEntry.prototype;\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}